<!DOCTYPE html><html>  <head>    <meta content="text/html; charset=ISO-8859-1" http-equiv="content-type">    <title>Workflow</title>    <script type="text/javascript" src="/jsc/app.js"></script>  </head>  <body>    <article class="content">      <script type="text/javascript" src="/jsc/ydn.db-dev.js"></script>      <script type="text/javascript" src="/js/ydn-db/data-seeding.js"></script>      <h2>Database connection</h2>      <p>Currently client sidex database are <a href="http://www.w3.org/TR/quota-api/#temporary">temporary          storage</a>. The data can be wipe out anytime without informing to        user or script. Data corruption instance has been observed to SQLite and        Chrome IndexedDB during opening the database. If corruption occur, whole        database or only certain object store can wipe out.&nbsp; &nbsp; </p>      <p>The most unpredictable operation is database connection. For an        application to robust, <a href="/api-reference/ydn-db/storage.html">storage          events</a> dispatched from the storage instance should be listened and        validate data integrity. <br>      </p>      <pre>var db_name = 'test-db-3';var options = {};db = new ydn.db.Storage(db_name, author_article_topic_schema, options);db.addEventListener('ready', function(ev) {  if (isNaN(ev.getOldVersion())) {    // new database is created    var authors = genAuthors(100);    db.put('author', authors);  } else if (ev.getVersion() &gt; ev.getOldVersion()) {    // schema upgrade, do data upgrade as necessary  } else {    // existing database open  }});db.addEventListener('fail', function(ev) {  var err = ev.getError();  // database connection fail, inform user  alert('Your data will not be saved, database opening failed wth ' + err.name);});</pre>      <h2>Transaction policy</h2>      <a name="transaction-policy"></a>      <h3>Parallel and serial tranasction thread</h3>      <p>This library hides the transaction layer for ease of use. Each database        operation method requires an active transaction. The transaction could        be created or reused. The selection is determined by transaction policy.        Multiple transactions can be created from a connection. Non blocking        transactions are execute in parallel. For example all readonly        transactions are executed in parallel. Executing parallel has        performance benefit, however we may want to preserve order. This library        provide transaction thread of either parallel or serial.&nbsp;</p>      <p>Consider for populating a store with records from a large delimited        text. To avoid holding memory for holding all records, data are download        by chunk using HTTP Range header by <code>CsvStreamer</code><code></code>        and invoke next callback when it read a record. A chunk of data comprise        multiple records and in that case <code>CsvStreamer</code> write        synchronously. While waiting for next chunk of data <code>CsvStreamer</code>        invoke next callback asynchronously. &nbsp; </p>      <pre>var stream = new CsvStreamer(url);var isSerial = false;var tdb = db.branch('multi', isSerial); // multi-request parallel transactionsvar putData = function(data) {  if (data) {     tdb.put('store1', data).then(function() {      stream.next(function (data) {           putData(data);    }), function(e) {      console.log(e.message || e);    });       }}); stream.next(function (data) {  putData(data);}</pre>      <p>In this example a new multi-request parallel transaction thread is        created using <code>branch</code> method. This kind of transaction        thread suitable for this use case, in which synchronous write use        existing transaction and asynchronous write use parallel        transaction.&nbsp; </p>      <p>A serial transaction thread is created by using <a href="file:///api-reference/ydn-db/storage.html#branch"><code>branch</code></a>        method with <code>isSerial</code> flag to <code>true</code>. In serial        transaction thread, a new transaction is created only after active        transaction is committed. Transaction request are queue and popped by        last-in-fast-out basic. The default transaction thread, which is        attached to the storage instance, is serial. Serial transaction thread        is used when order of execution is important. </p>      <h3>Request</h3>      <p>At the same time, multiple requests can place into a transaction. These        request are executed in order in the transaction it placed. Creating a        new transaction has higher cost than creating a new request. Hence        placing multiple requests on a transaction has huge performance over        running multiple transactions.&nbsp; </p>      <p> <strong>Single request policy </strong> (<code>'single'</code>):        Each <a href="getting-started.html#database-operation-methods">database          request methods </a>create a new request. If request is active, the        creating process is pushed into a queue. Whenever a request is completed        the queue is popped by last-in-first-out basic. This method satisfy        read-your-own-write consistency. </p>      <p> <strong>Atomic request policy </strong> (<code>'atomic'</code>):        Atomic serial queue transaction policy create transaction as in serial        queue transaction thread policy and intersect database request method by        holding result until transaction is committed. </p>      <p>If the request failed, when transaction is aborted. The database        request method cannot <a href="/api-reference/ydn-db/storage.html#abort">abort</a>        the transaction.&nbsp;</p>      <p> <strong>Multi-request policy </strong> (<code>'</code><code><code>multi</code>'</code>):        A new transaction is created if no active transaction or the active        transaction scope is not applicable for the requested database operation        method. If transaction is active but not reused, the creating process is        pushed into a queue. Whenever a transaction is completed the queue is        popped by last-in-first-out basic. </p>      <p><strong>Repeat request policy </strong> (<code>'repeat'</code>): This        is similar to multi-request policy but restrict to same transaction        scope. </p>      <p><strong>Explicit request policy </strong> (<code>''</code>):        Transaction is created by using explicit scope.</p>      <h3>Explicit transaction </h3>      <p> Transaction is used to achieve atomic, consistent, isolated database        operation. In this library, all database operation methods are performed        in an implicit transaction. However, sometimes, explicit transaction are        desirable. Although you can create an explicit transaction, its commit        still be implicit. None of the native API in IndexedDB nor WebSQL        provides to commit a transaction explicitly. </p>      <h4>For consistency</h4>      <p>An explicit transaction is performed by obtaining transaction database        instance&nbsp;using&nbsp;<a href="/api-reference/ydn-db/storage.html#run"><code>run</code></a>        method. This example demonstrates one use of transactions: updating an        entity with a new property value relative to its current value.</p>      <pre>amount = 10;db.run(function health_10up(tdb) { // tdb is transaction database instance   tdb.get('player', 1).done(function(p1_obj) {        p1_obj.health += amount;        tdb.put('player', p1_obj);   });  }, ['player'], 'readwrite');</pre> This requires a transaction because the value may be updated by another      user after this code fetches the object, but before it saves the modified      object. Without a transaction, the user's request uses the value of <code>health</code>      prior to the other user's update, and the save overwrites the new value.      With a transaction, the application is told about the other user's update.      If the entity is updated during the transaction, then the transaction is      retried until all steps are completed without interruption.      <p> If operation fail, the transaction is <code>abort</code> and relevant        <code>error</code> callback of the key will be invoked. As best        practice, keep transaction operation short and quick and resolve error        in early possible step. </p>      <p>This arrangement provides very natural and robust (meaning that <i>never          </i>you will encounter <code>InvalidStateError</code>) transaction        workflow on most web application requirement. &nbsp; &nbsp; &nbsp;</p>      <h4>Ensuring write</h4>      <p>The success callback in all database operation methods are invoked by <a          href="http://www.w3.org/TR/IndexedDB/#request-api">request          success</a> event. For a write database operation, a request success        does not grantee that data is written because its transaction it not        committed yet. The transaction commit can fail. To ensure database        write, the transaction completed can be listen using explicit        transaction.</p>      <pre>db.run(function health_10up(tdb) {    var req = tdb.put('player', obj).done(function(key) {    // put request is success, but not grantee written to the database    req.abort(); // we can still abort the request   });  }, ['player'], 'readwrite'function on_completed(type, e) {  if (type == 'complete') {    console.log('data written to the database.');  } else if (type == 'abort') {    console.log('aborted');  } else { // must be an error    console.log(e.message || e);  }});</pre>      <h4>For performance</h4>      <p>Creating a transaction is relatively expensive in compare to making a        request. Depending on transaction policy, each request may not reuse the        available active transaction. The following code explicitly create a        transaction re-used in the loop.</p>      <pre>db.run(function (tdb) {  data_list.forEach(function(data) {    tdb.put('store', data);  });});</pre>      <br>      <p>Parellel transaction thread create a new transaction immediate, where        as in serial transaction thread, transaction are created only if        previous transaction is commited. Overflow policy request to reuse the        previous transaction if compatible.</p>      <p>It should be noted that the above code avoid using large synchronous        loop. Instead asynchronous streaming is used.</p>      <h2>Storing File and Blob data</h2>      <p>IndexedDB can store beyound JSON serializable type, including File and        Blob. In fact, File storage is so successful that W3C is even        considering to use IndexedDB API over <a href="http://www.w3.org/TR/file-system-api/">FileSystem          API</a>. Currently only Firefox is supported these storage.</p>      <p>File and Blob should be store as single recrods with out-of-line key as        follow:</p>      <pre>var file_schema = {  stores: [    {      name: 'file',      type: 'TEXT'   // data type of 'file' object store key    }]};db = new ydn.db.Storage('file-test-1', file_schema);/** * @param {string} url URL of the file to be retrieved  * @param {Function=} callback optional callback */var saveImage = function(url, callback) {  var xhr = new XMLHttpRequest();    xhr.open("GET", url, true);  xhr.responseType = "blob";     xhr.addEventListener("load", function () {    if (xhr.status === 200) {      console.log("Image retrieved");              var blob = xhr.response;       // Put the received blob into IndexedDB      db.put('file', blob, url).done(function(key) {          console.log('Save to ', 'file:' + key);          if (callback) {callback(key);}        }      );    }  }, false);  xhr.send();};/** * @param {string} key the key of the image record */var showImage = function(key) {  db.get('file', key).done(function(record) {    // Get window.URL object    var URL = window.URL || window.webkitURL;     // Create ObjectURL    var imgURL = URL.createObjectURL(record);     // Set img src to ObjectURL        var img = document.createElement('img');    img.setAttribute('name', url);    img.setAttribute('src', imgURL);    document.body.appendChild(img);     // Revoking ObjectURL    URL.revokeObjectURL(imgURL);  }, function(e) {    console.log(e.message || e);  });};</pre>      <p>Load and save an image file</p>      <pre>url = 'http://dev.yathit.com/images/HTML5_logo_and_wordmark.png';saveImage(url);</pre>      <p>Image is retrieved by</p>      <pre>showImage(url);</pre>      <h2>Synchronization with backend server</h2>      <p>Synchronizing client database and backend RESTful server is fairly        straight forwards. To archive efficient synchronization, the        implementation is require more on server side than on client side. To        facilitate client side data caching, HTTP protocol provide two (four        methods) request header. Basically the state of the data is identified        by either etag or updated date or both. If etag is used, a GET request        include <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.26">If-None-Match</a>        header of know etag value from the client side data. Server return 304        without response body if the data not changed. For modification        requests, <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.24">If-Match</a>        header is used to prevent overriding wrong version of a resource. The        use case of modified date is similar.<br>      </p>      <p> A synchronization layer is required on top of CRUD methods (add, get,        put, clear). The example <a href="https://github.com/yathit/backbone-indexeddb-sync">synchronization          adapter</a> is available on Github repository for Backbone framework        on Google API backend. To notify changes in the database, storage        instance dispatch StoreEvent and RecordEvent for changes in the        database. The events are not dispatch by default because eventing        implementation is not cheap. The desire store must installed to dispatch        the events by setting <code>dispatchEvents</code> to <code>true</code>.</p>      <pre>var events_schema = {  stores: [    {      name: 'store 1',      keyPath: 'id',      dispatchEvents: true,      type: 'NUMERIC'}  ]};</pre>      <p>The events are listened as follow: </p>      <pre>db.addEventListener(['created', 'updated'], function(e) {    console.log(e.name); // this will be either 'RecordEvent' or 'StoreEvent'    console.log(e.getStoreName());    console.log(e.type); // this will be one of 'created', 'updated' or 'deleted'    // use getKey() and getValue() methods for RecordEvent    // use getKeys() and getValues() methods for StoreEvent});</pre>      <p>However to achieve efficiency in synchronization of collection of        models, it is not straight forward because HTTP (and REST) do not said        about conditional retrieval of collection of documents. A usual way is        fetching with query parameter of last updated time in the client side. A        demonstration of efficient retrieval using Google Data API (atom format)        is available in the repository.</p>      <br>    </article>    <script type="text/javascript">initDom()</script>  </body></html>