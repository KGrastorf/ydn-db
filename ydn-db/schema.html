<!DOCTYPE html><html>  <head>    <title>Schema</title>    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <link href="../../css/main.css" rel="stylesheet" type="text/css">    <script type="text/javascript" src="/jsc/app.js"></script>  </head>  <body>    <article class="content">      <script type="text/javascript" src="/jsc/ydn.db-dev.js"></script>      <script type="text/javascript" src="/js/ydn-db/data-seeding.js"></script>      <h2>Modeling relationships</h2>      <p>The NoSQL style databases has often been termed non-relational        databases. This is an unfortunate misconception. As we will see,        IndexedDB can easily model relationships. The real problem, however, is        it does not enforce integraty of the relationships. </p>      <p>A relationship is essentially a reference from one object to an object.        Which means, making a relationship is as simple as keeping a reference        of an object in an object. The reference will be a primary key. The        three kinds of relationships, one-to-one, one-to-many, many-to-many are        modeled by storing reference. The discussion here is how to records        these reference so that bi-directional transversable, efficient and        consistent. Unlike RMDB system, NoSQL do not have native support for        relationship. In fact, getting ride of relationship is the main        objective of NoSQL so as to offer in scalability and performance. People        tern to over-rely on relationship model suffering un-necessary        performance penalty.<br>      </p>      <h3>One-to-many relationship</h3>      <p>One-to-many relationship is modeled by keeping 'one' reference to        objects in 'many' side. Reference is simply a primary key, which could        be a string or an integer. </p>      <p>Refering to 'author' object store in previous session, the 'author',        store has one index of named 'company'. 'author' store is related to        'company' store by defining the following store schema. </p>      <pre>company_store_schema = {  name: 'company',  keyPath: 'name',  type: 'TEXT'};</pre>      <p>Additionally, the value of 'company' attribute in the 'author' record        is restricted to valid primary key of company records. This consistency        has to be inforce by the application. In the future version, the library        may add such foreign key relationship enforcement.</p>      <pre>schema = {  stores: [author_store_schema, company_store_schema]};db = new ydn.db.Storage('test-2', schema);db.put('company', companies);db.count(['author', 'company']).done(function(cnts) {  console.log(cnts[0] + ' authors and ' + cnts[1] + ' companies.');});</pre>      <p>We can query the relationship from both direction. To query authors on        particular company: </p>      <pre>db.values('author', 'company', ydn.db.KeyRange.only('Google'), 10).done(function(authors) {  console.log(authors);});</pre>      <h3>One-to-one relationship</h3>      <p>One to one relationships are essentially a special-case of one to many        relationships. Like one to many relationships, they are usually        accomplished with a reference primary key on one side referring to the        other object store.</p>      <h3>Parent-child relationship</h3>      <p>Parent child relationship is in face one to many relationships. To        enforce, parent-child relationship, we can use array keyPath in child        object store. The primary key of the child record consists primary key        of parent object store and child id. The following 'article' child store        schema illustrate parent-child relationship with 'author' store. </p>      <pre>blog_schema = {  stores: [{    name: 'author',    keyPath: 'email'  }, {    name: 'article',    indexes: [{      keyPath: 'title'    }, {      keyPath: 'tag',      multiEntry: true    }]  }]};</pre>      <p>The 'author' store use 'email' attribute for in-line primary key. Using        email for primary key is smart because email is <strong>unique</strong>        to author. Email is the most likely information we know and query. <em>Data          type</em> of 'TEXT' is given to primary key by using <code>type</code>        <em>schema attribute</em>. It is not used in IndexedDB, but used in        WebSQL. In fact, it is required to perform native SQL query. </p>      <p>The 'article' store do not specified <code>keyPath</code> schema        attribute and hence it must use out-of-line key. The primary key type is        specified as an array of two 'TEXT'. It uses array because it has two        parts. Its first element is primary key of 'author' store ('email') and        the second element is 'article' 'title'. This key construction enforces        that 'article' must has one 'author' and a unique title for each author.        'author' store is called <em>parent store</em> and 'article' store is        called <em>child store</em>.<br>      </p>      <p>'title' of 'article' attribute is indexed and hence it becomes <em>index          key</em>. Like primary key, index key can be used to retrieve the        record directly. Unlike primary key, index key is not necessary to be        unique. However unique integrity is desired, it can be enforced by <code>unique</code>        schema attribute.&nbsp; </p>      <p>'tag' is <em>listed index</em> because its <code>multiEntry</code>        schema attribute set to <code>true</code>. Listed index field value        must be an array, otherwise it will not be indexed. Listed index field        value are indexed element-wise. Here is sample data:<br>      </p>      <pre>author1 = {  first: 'Micheal',  last: 'Bolin',  email: 'bolinfest@gmail.com'};author2 = {first: 'Kyle',last: 'Huey',email: 'me@kylehuey.com' }article1 = {  title: 'Inheritance Patterns in JavaScript',  url: 'http://bolinfest.com/javascript/inheritance.php',  tag: ['javascript', 'design pattern', 'closure tools']}article2 = {  title: 'Writing useful JavaScript applications in less than half the size of jQuery',  url: 'http://blog.bolinfest.com/2011_07_01_archive.html',  tag: ['javascript', 'closure tools', 'jquery']}article3 = {  title: 'Fixing the Memory Leak',  url: 'http://blog.kylehuey.com/post/21892343371/fixing-the-memory-leak',  tag: ['browser', 'firefox', 'memory']}article4 = {  title: 'Pushing Compilers to the Limit (and Beyond)',  url: 'http://blog.kylehuey.com/post/14453464655/pushing-compilers-to-the-limit-and-beyond',  tag: ['javascript', 'firefox', 'performance', 'jit']}</pre>      <p>Create a new database and insert them.</p>      <pre>blog_db = new ydn.db.Storage('blog', blog_schema);blog_db.put('author', [author1, author2]);blog_db.put('article', article1, [author1.email, article1.title]);blog_db.put('article', article2, [author1.email, article2.title]);blog_db.put('article', article3, [author2.email, article3.title]);blog_db.put('article', article4, [author2.email, article4.title]);</pre>      <p>Notice how out-of-line keys are constructed for 'article' store. This        database library should automatically generated such parent-child        relationship key.</p>      <p>Let us query how many 'javascript' articles.</p>      <pre>blog_db.count('article', 'tag', ydn.db.KeyRange.only('javascript')).done(function(count) {  console.log(count)})</pre>      <p>Here list article 'title' by Micheal Bolin in the database.</p>      <pre>blog_db.keys('article', ydn.db.KeyRange.starts(['bolinfest@gmail.com'])).done(function(keys) {  for (var i = 0; i &lt; keys.length; i++) {    console.log(keys[i][1]);  }});</pre>      <p>The following code snippet query primary keys sorted by index key        'title'.</p>      <pre>blog_db.keys('article', 'title').done(function(keys) {  for (var i = 0; i &lt; keys.length; i++) {    console.log(keys[i][1]);  }});</pre>      <h3>Many-to-many relationship</h3>      <p>Many to many relationships are the most complex to implement in any        system, and several solutions are available. The most obvious approach        is the same as that used in relational databases: a 'join table', which        contains pairs of keys from both sides of the relationship. </p>      <pre>friendship_store_schema = {  name: 'friendship',  indexes: [    {      keyPath: 'author1'    }, {      keyPath: 'author2'  }]};</pre>      <p>Another approach is to have one side of the relationship store a list        of the keys of records on the other side of the relationship. This makes        the most sense when the cardinality on one side is limited (say, to a        few hundred or less), when there is a natural 'owner' of the        relationship, or when you want to be able to easily update the list of        referenced entities in bulk.</p>      <p>This is illustrage by relationship between 'topic' and 'article'        stores.</p>      <pre>topic_store_schema = {  name: 'topic',  keyPath: 'name'};article_store_schema = {  name: 'article'  indexes: [    {      keyPath: 'title'    }, {      keyPath: 'publish'    }, {      keyPath: 'license'    }, {      keyPath: 'publisher'    }, {      keyPath: 'topics',      multiEntry: true  }]};</pre>      <h3>Schema for relationships</h3>      <p>In the fugure, the library intent to provide relationships by        annotating with the following keywords in the schema. </p>      <table class="gridtable">        <thead>          <tr>            <th>Keyword</th>            <th>Description</th>          </tr>        </thead>        <tbody>          <tr>            <td><code>parent</code></td>            <td>parent key annotated in child store, parent-child consistency              enforce</td>          </tr>          <tr>            <td><code>reference</code></td>            <td>key to refer one-to-many relationship</td>          </tr>          <tr>            <td><code>embedded</code></td>            <td>key to refer one-to-many relationship with convenient retrieval              and enforce consistency </td>          </tr>          <tr>            <td><code>referenceList</code></td>            <td>key to refer many-to-many relationship</td>          </tr>          <tr>            <td><code>embeddedList</code></td>            <td>key to refer many-to-many relationship with convenient retrieval              and enforce consistency </td>          </tr>        </tbody>      </table>      <script type="text/javascript">initDom()</script> </article>  </body></html>