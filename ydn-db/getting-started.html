<!DOCTYPE html><html>  <head>    <meta content="text/html; charset=iso-8859-1" http-equiv="content-type">    <title>Setup</title>    <link href="../css/main.css" rel="stylesheet" type="text/css">    <script type="text/javascript" src="/jsc/app.js"> </script>  </head>  <body>    <article class="content">      <script type="text/javascript" src="/jsc/ydn.db-dev.js"></script> <script type="text/javascript" src="/js/ydn-db/data-seeding.js"></script> <div dir="ltr">        <h2>&nbsp; <a name="TOC-Setting-up-YDN-DB-javascript-module">Getting            started with YDN-DB javascript module </a></h2>        <h2  id="h2-setup">Setup</h2>        <p>YDN-DB is a pure javascript library, which uses HTML5 browser          database sunch as IndexedDB, WebDatabase (WebSQL) and WebStorage          (localStorage). Most modern browsers including IE10, Chrome, Firefox          and Safari support either IndexedDB or WebSQL. The library can also be          used in web client such as phonegap, WebView and UIWebView mobile          clients.</p>        <p><a href="http://dev.yathit.com/index/downloads.html">Download</a> <em>a</em>          javascript file from the pre-compiled distribution files. These file          are minified for selected feature set. For development you should want          to use ydn.db-x.x-dev.js, which enforces assertion and provides          logging.</p>        <p>Installed by <a href="http://bower.io">bower</a>:</p>        <pre>bower install ydn.db         </pre>        <p>In browser:</p>        <pre>&lt;script type="text/javascript" src="ydn.db-iswu-core-e-qry-dev.js"&gt;&lt;/script&gt;</pre>        <p>In an AMD loader:</p>        <pre>require({  'packages': [{'name': 'ydn', 'location': 'path/to/ydn-db', 'main': 'ydn.db-iswu-core-e-qry-dev'}]}, ['ydn'], function(ydn) {  console.log(ydn.db.version);  var db = new ydn.db.Storage('db name');});</pre>        <p>The namespace of this library is <code>ydn.db</code>. The script          provide main javascript class object, called <code>ydn.db.Storage</code>.        </p>        <div class="box"> Pages in this sections include the YDN-DB script and          some preloaded data and utility functions, so that you follow the          sample code in your browser's developer console to see in action. </div>        <h2  id="h2-database-connection">Database connection</h2>        <p>A simple way to initialize a database is by specifying a database          name. </p>        <pre>db = new ydn.db.Storage('db-name');db.put('store-name', {message: 'Hello world!'}, 'id1');db.get('store-name', 'id1').always(function(record) {  console.log(record);});</pre>        <p>The storage instance, <code>ydn.db.Storage</code>, connects to          suitable data storage mechanisms starting from IndexedDB to WebSQL to          localStore. It will open existing database or create a new database          with the given database name.</p>        <p>All database operation methods are asynchronous and result are&nbsp;          return as a deferred object. It is also called future or promise          object. The resulting <i>deferred object</i> accepts two asynchronous          functions:&nbsp;<code>done</code>&nbsp;to receive value on success          event and <code>fail</code>&nbsp;to received in case of error. A          convenient <code>then</code>&nbsp; accept both of them. In case of          error, this library always invokes <code>error </code>callback with          <code>Error </code>object with has <code>name</code> attribute and <code>message</code>          attribute.&nbsp;</p>        <div class="box"> <a name="TOC-Basic-usage">If you use raw source            code,&nbsp;<i>deferred object</i>&nbsp;is </a><a href="http://code.google.com/p/closure-library/source/browse/trunk/third_party/closure/goog/mochikit/async/deferred.js"><code>goog.async.Deferred</code></a>          class, which is also similar to <a href="http://api.jquery.com/category/deferred-object/">JQuery            Deferred</a> &nbsp;or <a href="http://msdn.microsoft.com/en-us/library/windows/apps/br211867.aspx">WinJS.Promise</a>.          Both of them provides advanced asynchronous          workflow.&nbsp;&nbsp;&nbsp;&nbsp; </div>        <h2  id="h2-storing-data">Storing data</h2>        <p>Use <code>put</code> method to insert a new or update existing          record(s).</p>        <h3>Out-of-line key</h3>        <pre>db.put('store1', {test: 'Hello World!'}, 123).done(function(key) {  console.log(key);});</pre>        <p>The first argument is store name. It is <a href="http://www.w3.org/TR/IndexedDB/#object-store-concept">object            store</a> name in IndexedDB and TABLE name in WebSQL. Since a schema          is not given, a table or object store will be created if not exist.<br>        </p>        <p>The second argument is the record we want to store. It should be a          simple object. A <a href="http://www.w3.org/TR/html5/common-dom-interfaces.html#internal-structured-cloning-algorithm">structuredclone            of the object</a> is stored in the database. A structured clone is          similar concept in JSON serialization. But it is more efficient and          more powerful. File and Blob are clonable, while&nbsp; DOM Element is          not. If the record fail to clone it, underlying database API shall          throw <code>DataCloneError</code>.&nbsp; </p>        <p>The third argument is <em>primary key</em> of the record. A <a href="http://www.w3.org/TR/IndexedDB/#key-construct">key</a>          can be number, string, Date or simple array. Since we are given          primary key separately from the record, it is called <em>out-of-line</em>          key.&nbsp;</p>        <p>Use <code>get</code> method to retrieve it by the primary key. </p>        <pre>req = db.get('store1', 123);req.done(function(record) {  console.log(record);});req.fail(function(e) {  console.log(e.message || e);});</pre>        <h3>In-line key</h3>        <p>Primary key can be embedded into the record value. We specify how to          extract the primary key from the record by using <em>keyPath</em>. </p>        <pre>record = {id: 'abc', message: 'Testing in line key'};req = db.put({name: 'store2', keyPath: 'id'}, record);req.done(function(key) {  console.log(key);});req.fail(function(e) {  console.log(e.message || e);});</pre>        <p>Here, we are giving <em>store schema</em> in the first argument          instead of just store name. The two store schema attribute are 'name'          and 'keyPath'. A record is inserted to 'store2' store by using primary          key 'abc'. Since primary key is specified in the record object, it is          called, <em>in-line </em>key. </p>        <p>Set <code>autoIncrement</code> of the <em>store schema attribute</em>          to <code>true</code> to let the database engine to generate a          increasing primary key when it is not provided. <em>Auto key            generation</em> works for both in-line and out-of-line key. </p>        <h2  id="h2-retrieving">Retrieving</h2>        <p>Keys are the <strong>most</strong> efficient way to retrieve a          record. If we don't know the key, we <strong>must</strong> browse the          whole store to find it. Let us add some more records. </p>        <pre>var data = [{id: 'a', message: 'a record'}, {id: 'b', message: 'b record'}];db.put('store2', data).always(function(x) {    console.log(x);});</pre>        <p>Notice multiple records are stored by using array of records in one          transaction.</p>        <p>Record values are retrieved by using&nbsp;<code>values</code>          database operation method.<br>        </p>        <pre>db.values('store2').done(function(records) {  console.log(records);});</pre>        <p>We can also retrieve only primary key of the records using <code>keys</code>          database operation method. . </p>        <pre>db.keys('store2').done(function(records) {  console.log(records);});</pre>        <p>In contrast to listing record values, key listing is much faster          because it obviates serialization. Key is very important for effective          querying. And hence keys should be carefully constructed. In addition          to primary key, there is <em>secondary key</em>, which is simply          called as <em>index key</em>.<br>        </p>        <h2 id="h2-schema">Schema</h2>        <p>While running the above codes, we modified database schema on          creating new stores. It is not preferable in production usage, because          modifying database schema is not a trivial process. It need to          notified all connections on other tabs including worker thread as          well. Additionally we should use a fixed schema through out a web          application for consistency. The database schema from the database          connection is retrieved as follow. </p>        <pre>db.getSchema(function(schema) {  console.log(schema);});</pre>        <p>You will find database version is <code>undefined</code>, since we          are not giving a database version. The database is said to be in <em>auto-version</em>          mode. <br>        </p>        <p>A <a href="/api-reference/ydn-db/schema.html">database schema</a> is          basically defining object stores or TABLE in WebSQL. An example is</p>        <pre>var author_store_schema = {  name: 'author',  keyPath: 'email', // optional,   autoIncrement: false, // optional.   indexes: [    {      name: 'born', // optional      keyPath: 'born',      unique: false, // optional, default to false      multiEntry: false // optional, default to false    }, {      name: 'company'    }, {      name: 'hobby',      multiEntry: true    }  ] // optional, list of index schema as array.};schema = {  stores: [author_store_schema]};</pre>        <p>The above schema define one object store. The name of object store is          'author'. Since <code>keyPath</code> is defined, it is using in-line          key. Since <code>autoIncrement</code> is <code>false</code>, all          records must have a valid key in its 'email' field attribute. </p>        <p>The object store 'author' has three <em>secondary indexes</em>,          namely 'born', 'company' and 'hobby'. In WebSQL, they are column names          of TABLE 'author'.          If <code>keyPath</code> is not defined, it is default to <code>name</code>.          An example 'author' record will be: </p>        <pre>author_1 = {  email: 'me@aaronsw.com',  born: 531763200000,  first: 'Aaron',  last: 'Swartz',  company: 'Reddit',  hobby: ['programming', 'blogging', 'politics']};</pre>        <p>If index schema attribute, <code>unique</code> is <code>true</code>,          unique constraint is applied on the index key. If unique constraint is          void during a database write operation, <a href="http://www.w3.org/TR/IndexedDB/#dfn-constrainterror">ConstriantError</a>          will issue.&nbsp; </p>        <p>The index schema attribute, <code>multiEntry</code> is meaningful          only for key value of array data type. The index 'hobby' has <code>multiEntry</code>          of <code>true</code>, so that each element in of the array hobby are          indexed individually. <br>        </p>        <p>In addition to 'stores' attribute, database schema take 'version'          attribute. If version number is specified, the library will open with          the given version. If the client browser do not have or lower than the          given version, it will be upgraded as necessary. Client version must          not be higher than given version. If client version is the same as          given version, the database schema must be similar. If not similar,          the library will refuse to connect the database. This library will not          work, if schema is not known. </p>        <p>Let us generate some data for querying.</p>        <pre>genAuthors = function(n) {  var out = [];  for (var i = 0; i &lt; n; i++) {    out[i] = {      first: randName(),      last: randName(),      born: +(new Date(1900+Math.random()*70, 12*Math.random(), 30*Math.random())),      email: randEmail(),      company: pickOne(companyList),      hobby: pickMany(hobbyList)    };  }  return out;};</pre>        <pre>db = new ydn.db.Storage('test-2', schema);var authors = genAuthors(10000);db.put('author', authors).then(  function(ids) {    console.log(ids.length + ' authors put.');  }, function(e) {    console.log(e.message || e);  });</pre>        <p><code>put</code> method uses multiple asynchronous threads and          generally very fast.</p>        <h2  id="h2-basic-query">Basic query</h2>        <p>If you don't know the exact key, you must enumerate the whole or a          range of object store records. Here the process is called querying.          Instead of enumerating records, you can only enumerate only key. This          is called <em>key only query</em>. Key only query is very efficient          because the most expensive operations of IO and de-serialization are          avoided. </p>        <h3>Counting</h3>        <p>Generally NoSQL database does not provide counting, but IndexedDB API          does.</p>        <pre>db.count('author').done(function(x) {  console.log('Number of authors: ' + x);});</pre>        <p>This is the only aggregate function provided by the IndexedDB API.</p>        <h3>Sorting</h3>        <p>Keys are sorted in the database and hence database query results are          <em>always</em> sorted in some way. By default, the following query          is sorted by primary key, 'email'. </p>        <pre>var key_range = null;db.from('author').list(10).done(function(records) {  console.log(records);});</pre>        <p>If sorting is required, the sorted field have to be indexed. The following          illustrate iterating records sorted by 'born' date field, one of the          three indexed fields. </p>        <pre>db.from('author').order('born').list(10).done(function(records) {  console.log(records);});db.from('author').order('born').reverse().list(10).done(function(records) {  console.log(records);});        </pre>        <p>The following example retrieve list of unique hobbies.</p>        <pre>db.from('author').select('hobby').unique(true).list().done(function(hobby) {  console.log(hobby);});</pre>        <h3>Filtering</h3>        <p>The primary way of filtering is query by <a href="/api-reference/ydn-db/keyrange.html">key            range</a>. More sophisticated filtering are iterated merging of key          range results. We dedicate these sophisticated filtering on later          sections.</p>        <p>The following query finds authors born in 1942 February.</p>        <pre>var lower = + new Date(1942, 1, 1); // 1942 February 1var upper = + new Date(1942, 2, 1); // 1942 March 1db.from('author').where('born', '&gt;=', lower, '&lt;', upper).list().done(function(records) {  console.log(records);  records.map(function(x) {    console.log(x.first + ' ' + x.last + ' ' + new Date(x.born));  });});</pre>        <h3>Paging</h3>        <p><code>keys</code> and <code>values</code> methods accept <code>limit</code>          and <code>offset</code> for paging. Iterator has <em>position state            property</em>. The position of an iterator is the last cursor          position defined by effective key and primary key.</p>        <p>The following query list all authors having hobby in 'camping' using          iterator and paging.<br>        </p>        <pre>var q = db.from('author').where('hobby', '=', 'camping');q.list(10).then(function(records) {  console.log(records);  console.log('From ' + records[0].email + ' to ' + records[records.length - 1].email);}, function(e) {  console.log(e.message || e);});</pre>        <p>Also notice that the result is sorted by primary key. To continue          next page, call list method again.</p>        <pre>q.list(10).then(function(records) {  console.log(records);  console.log('From ' + records[0].email + ' to ' + records[records.length - 1].email);}, function(e) {  console.log(e.message || e);});</pre>        <p>Notice that offset value is not used.</p>        <h2  id="h2-updating">Updating</h2>        <p>Use <code>open</code> method to update records. </p>        <pre>var iter = new ydn.db.ValueIterator('author', ydn.db.KeyRange.starts('a'));var mode = 'readwrite';var updated = 0;var deleted = 0;db.open(function(cursor) {  var author = cursor.getValue();  if (author.company == 'Oracle') {    cursor.clear().done(function(e) {      deleted++;    });  } else if (author.category != 'A') {    author.category = 'A';    cursor.update(author).done(function(e) {      updated++;    });  }}, iter, mode).then(function() {  console.log(updated + ' records updated, ' + deleted + ' deleted.'); });</pre>        <h2  id="h2-debugging">Debugging</h2>        <p>Use <em>dev</em> version of the compile JS file during development.          Put <em>.map</em> file in the same directory as js file. Turn on <a            href="http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/">source            map</a> for debugging with full source code. Use build-in logging          facility to detail logging.</p>        <pre>var module = 'ydn.db';var level = 'finer'; // warning, info, fine, finest, allydn.debug.log(module, level);</pre>        <h2  id="h2-summary">Summary</h2>        <div> <a name="database-operation-methods"></a>          <table class="gridtable">            <caption>Database operation methods</caption>            <thead>              <tr>                <th>Read</th>                <th>Description</th>              </tr>            </thead>            <tbody>              <tr>                <td>get</td>                <td>Get a record</td>              </tr>              <tr>                <td>keys</td>                <td>Get a list ordered keys, or effective keys of an iterator<br>                </td>              </tr>              <tr>                <td>values</td>                <td>Get a list ordered records, or reference values of an                  iterator<br>                </td>              </tr>            </tbody>            <thead>              <tr>                <th>Write</th>                <th>Description</th>              </tr>            </thead>            <tbody>              <tr>                <td>add</td>                <td>Add record(s)</td>              </tr>              <tr>                <td>clear</td>                <td>Delete record(s)</td>              </tr>              <tr>                <td>put</td>                <td>Add or update record(s)</td>              </tr>            </tbody>            <thead>              <tr>                <th>Iterate</th>                <th>Description</th>              </tr>            </thead>            <tbody>              <tr>                <td>map</td>                <td>Map reference values of an iterator</td>              </tr>              <tr>                <td>open</td>                <td>Open an iterator for read/write operation</td>              </tr>              <tr>                <td>reduce</td>                <td>Reduce reference values of an iterator</td>              </tr>              <tr>                <td>scan</td>                <td>Scan keys of an iterator</td>              </tr>            </tbody>            <thead>              <tr>                <th>Aggreate</th>                <th>Description</th>              </tr>            </thead>            <tbody>              <tr>                <td>count</td>                <td>Count records</td>              </tr>            </tbody>          </table>        </div>        <h2  id="h2-exercises">Exercises</h2>        <div class="exercise">          <ol>            <li><details name="DataCloneError"><summary>Write a script that will                  throw DataCloneError.</summary>                <p>There are two primary way that cause DataCloneError.</p>                <p>One is the data include unsupported data type.</p>                <pre>db.put('store1', {ele: document.getElementsByTagName('div')[0]}, 2)</pre>                <p>Another one is circular referencing.</p>                <pre>cir_array = [1];cir_array.push(cir_array);db.put('store1', {data: cir_array}, 3);</pre>              </details></li>            <li><details name="DataError"><summary>Write a script that will                  throw DataError.</summary></details></li>            <li><details name="qa-function"><summary>Why a function cannot be                  persisted in the database? How will you re-store an javascript                  object?</summary>                <p>Function is not persisted in the database because function is                  not serialized by structured clone algorithm.</p>                <p>Unlike JSON object, javascript object has methods, which are                  functions and will not be restored. The technique for                  restoring javascript object is similar to serialization in                  other programming language. A static factory method or the                  constructor that accept serialized object data is used.</p>              </details></li>          <li><details name="qa-double-sort"><summary>How do retrieve only selected fields of              a record?</summary>          IndexedDB API, hence YDN-DB, is key-value store. It is not possible to retrieve or store partial              record. All read/write to database are full record.</details></li>            <li><details name="qa-double-sort"><summary>How do you create an                  index to 'article' store to get primary keys sorted by 'first'                  followed by 'last'?</summary></details></li>            <li><details name="qa-exists"><summary>How will you test a key is                  existed in an object store?</summary>The most effecient way to                check existence of key is using <code>count</code> method,                which return 1 if the key exists in the object store. <code>get</code>                method is not only inefficient, since it involves record                retrieval, but also fail to distinguish between undefined record                value and non-existing key.</details></li>            <li><details><summary>Explain indexing is useful for projection                  query or not? Plan a database schema to facilitate projection                  querying to 'first' and 'last' field of 'article' store.</summary></details></li>            <li><details><summary>How will you query a list of emails from a                  certain domain, such as 'gmail.com'?</summary></details></li>            <li><details><summary>IndexedDB API does not support indexing                  boolean value. Why? What are the implications?</summary></details></li>            <li><details><summary>Describe how listed index can be used for                  many-to-many relationship.</summary></details></li>          </ol>        </div>        <script type="text/javascript">initDom()</script> </div>    </article>  </body></html>