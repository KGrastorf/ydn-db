<!DOCTYPE html><html><head><title>GAE login server</title><meta http-equiv="Content-Type" content="text/html; charset=utf-8" /><script type="text/javascript" src="/jsc/app.js"></script></head><body><article class="content"><script type="text/javascript" src="/jsc/ydn.auth-min.js"></script><div dir="ltr"><h2><a name="TOC-GAE-proxy-login-server" />GAE proxy login server</h2>
<p>
In modern web app implementation, specialize servers are used for the right job. <a href="https://developers.google.com/appengine/">Google Appengine</a> is the one right for login server. It is very secure as login server, easy to use and most of the case, it will fit on free tier. </p>
<p>
All of our login implementations use OpenID services. Now a day, no user want yet another user name and password just to receive junk mails and inconvenient of account activation and password reset.  
</p>
<p>
Since main app is running on CDN static server, the login server will be in different domain. We set proper header to accept cross origin request. In Python, <code>webapp2.RequestHandler</code> is extends as
</p>
<pre>class XhrRequestHandler(webapp2.RequestHandler):
	"""Cross Origin enable Request handler
	"""

	def initialize(self, request, response):
		super(XhrRequestHandler, self).initialize(request, response)
		
		origin = request.headers.get('Origin')
		
		if origin in ALLOW_HOST:
			response.headers['Access-Control-Allow-Origin'] = origin
		response.headers['Access-Control-Allow-Credentials'] = 'true'
		response.headers['Access-Control-Allow-Headers'] = 'Content-Type,GData-Version,If-Match,If-Not-Match'
		response.headers['Access-Control-Allow-Methods'] = 'GET,POST,PUT,DELETE,OPTIONS,HEAD'
		response.headers['Access-Control-Max-Age'] = '360000' # in second
		response.headers['Cache-Control'] = 'no-cache'
		#logging.info('cross origin ok for ' + str(origin) + ' to ' + self.request.path)

	def head(self, *args):
		self.response.set_status(200)

	def options(self, *args):
		self.response.set_status(200)
</pre>
<p> <code>ALLOW_HOST</code> is list of domains we accept. CORS enable request handler can simple extend the above as follow:</p>
<pre>class RpcLogin(XhrRequestHandler):
	"""CORS login request handler
	"""
	output = {}
	def get(self):
		user = users.get_current_user()
		redirect_url = self.request.url
		if redirect_url not in ALLOW_HOST:
			self.response.set_status(401)
			return
		else 
			redirect_url = '/rpc_redirect?page=' + redirect_url
		if user:
			output['email'] = user.email()
			output['logout_url'] = users.create_logout_url(redirect_url)<br />		else:
			output['login_url'] = users.create_login_url(redirect_url)
		self.response.out.write(json.dumps(output))
</pre>
<p>
After user login, appengine will redirect back to /rpc_redirect url, which we simple redirect back to the web app.  </p>
<pre>class RpcRedirect(webapp.RequestHandler):
	"""Redirect after login
	"""

	def get(self):
		page = self.request.get('page')
		if not page:
			page = '/'
		self.redirect(page)
</pre>
<p>
This redirection is necessary because appengine itself is not login server but outsource to OpenID provider. It will redirect only to the appengine domain. 
</p>
<p>Once user login, appengine set secure HTTP-only session cookie. Login server logic is pretty much that is. Next request from the web app have the cookie and current user object would is already set. </p>
<p>This login technique is very secure because user go though full page https login followed by registered redirect URLs and each steps check tempering of one-time nonce. </p>
<p>For extra security measure, we may want to pass additional random CSRF token to the web app. Additionally user activity should be log for some time.
</p>
<p><a href="/demo/ydn-login/gae_demo_app.html">Example</a> implementation can be found in <a href="https://bitbucket.org/ytkyaw/ydn-auth" >ydn-auth</a> repo.</p></div></article><script type="text/javascript">initDom()</script></body></html>